# FYPJ_AI_MALWARE
# Created by Goh Ee Sheng 2022, NYP FYPJ 2022 P4
# Supervisor: Dr Brandon Ooi

This project is in collaboration with CSIT to develop AI models for predicting malware attribution. Students will collect and process malware samples, extract features, build and test AI models, and produce a detailed study of the use of AI models in the malware attribution problem.

# Week 1 
* Research on malware using AI and Sandbox Technology.
* Read and analyse what previous NYP researchers did.

### Challenge 
    - Fix Kaelan's unzip.py
        * Now able to unzip .7z, .rar, .zip folders regardless of OS.

# Week 2 
## Official Work starts
### Preprocess malware Portable Executables

* Research on malware using AI and Sandbox Technology.
* Read and analyse what previous NYP researchers did.
* Use pre-trained VGG19 model to train with pre-processed data.

### Challenge 

    Preprocess malware images collected from the internet including polymorph malware
    - Create Python scripts.
        1. convert_pdf_doc.py
            - Convert PDFs and Word Documents into grayscale images.

        2. convert_bin_to_img.py
            - Convert compiled malware (i.e., .msi, .exe, .jar) into grayscale images.

        3. resize.py
            - Able to resize original images in directory to specific width and height

        4. train_test_split.py
            - Split datasets in to train and test folders.


# Week 3
* Use pre-trained VGG19 model to train with pre-processed data.

### Challenge 
    - Merge Python script into a singular file with python parser module.
        1. bin_to_img.py
            - Convert any files including malwares into grayscale images.


### Troubleshoot
    - Edit the notebook to allow grayscale image as input_data

### Lesson Learnt
```There is another way in preprocessing data. Basically, get the training datasets that are grouped in classes and convert them to numpy array immediately. Do not need to waste time and disk space for the pre-processed images.```
    
``` 
* Use this on original images - Instead of resizing every image and store in another folder.

    def imagearray(path,size):
    data = []
    for folder in os.listdir(path): # Loop the train/test folder
        sub_path = path +"/" + folder # Subfolder - Classes
        for img in os.listdir(sub_path): # Loop the images
            image_path = sub_path + "/" + img
            img_arr = cv2.imread(image_path)
            img_arr = cv2.resize(img_arr,size)
            data.append(img_arr)
    return data 
```
      
```To pad grayscale images to the same width and height, you can use the resize method from a library like OpenCV or Pillow. This method allows you to specify the target width and height for the resized images, and it will automatically pad the images with zeros to ensure that they have the specified dimensions.```

```
    Here is an example of how you might use the resize method from the OpenCV library to pad your grayscale images:
    # Import the necessary libraries
    import cv2

    # Load the grayscale image
    img = cv2.imread('grayscale_image.png', cv2.IMREAD_GRAYSCALE)

    # Resize the image to the desired width and height
    img = cv2.resize(img, (1024, 1024))

    # Save the resized and padded image
    cv2.imwrite('resized_image.png', img)
```
```In this example, the grayscale image is first loaded from a file using the imread method from OpenCV. The resize method is then used to resize the image to the desired width and height, and the resulting image is saved to a new file using the imwrite method.```

```Keep in mind that this is just an example, and you may need to adjust the code to fit your specific use case. Additionally, this code assumes that your grayscale images are in the PNG format and that you want to save the resized and padded images in the same format. You may need to modify this code to handle other image formats or to save the images in a different format.```
